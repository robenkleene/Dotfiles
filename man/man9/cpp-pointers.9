.\" Automatically generated by Pandoc 3.4
.\"
.TH "CPP\-POINTERS" "9" "" "Reference"
.IP \[bu] 2
A raw pointer is a variable that contains the memory address of an
object (or function)
.IP \[bu] 2
A \f[CR]unique_ptr\f[R] is a wrapper around a raw pointer that removes
the copy and copy assignment constructors to ensure there\[cq]s only one
owner of the managed object
.IP \[bu] 2
Prefer references (\f[CR]Bar& foo\f[R]) over pointers
(\f[CR]Bar* foo\f[R]) because references can\[cq]t be null
.IP \[bu] 2
A reference (e.g., \f[CR]Bar& foo\f[R] as a function parameter) is just
a pointer that can\[cq]t be null
.IP \[bu] 2
\f[CR]const\f[R] means that a pointer can be assigned, e.g.,
(\f[CR]const int foo\f[R]) can\[cq]t do \f[CR]*foo = 42\f[R]
.IP \[bu] 2
When an variable object is \f[CR]const\f[R] it can only access methods
on its class that are also marked \f[CR]const\f[R]
.IP \[bu] 2
If a method constructs an object and wants to return that object, you
have to use a raw pointer (the caller can then manage the result with a
smart pointer).
This is because you can\[cq]t use a reference, because there\[cq]s no
exiting object to reference, and you can\[cq]t use a
\f[CR]unique_ptr\f[R] because a \f[CR]unique_ptr\f[R] will be destroyed
at the end of the method.
.SH References
A reference is just that, a reference to an existing object, this means
for example that you can\[cq]t have a function returns a reference
return a local variable, because that\[cq]s variable is temporary value
that will leave memory at the end of its scope (and a reference
can\[cq]t be null).
.SH \f[CR].\f[R] vs.\ \f[CR]\->\f[R]
.IP \[bu] 2
\f[CR]foo.bar\f[R]: Access a member variable
.IP \[bu] 2
\f[CR]foo\->bar\f[R]: Access a member variable on a pointer (shorthand
for \f[CR](*foo).bar\f[R])
.SH \f[CR]*\f[R] vs.\ \f[CR]&\f[R] vs.\ \f[CR]unique_ptr\f[R]
For a \f[CR]unique_ptr\f[R] member variable:
.IP
.EX
std::unique_ptr<Foo> foo;
.EE
.PP
The constructor takes a reference:
.IP
.EX
foo(&fooIn)
.EE
.PP
The \f[CR]&\f[R] returns the address, so a \f[CR]unique_ptr\f[R]
constructor takes a raw pointer.
.SS \f[CR]unique_ptr\f[R] to Raw Pointer
\f[CR]get()\f[R] is used to access the raw pointer.
.PP
If a function takes a pointer as a parameter:
.IP
.EX
void SetFoo(Foo* const bar);
.EE
.PP
To pass in a \f[CR]unique_ptr\f[R], use \f[CR]get\f[R]:
.IP
.EX
SetFoo(foo\->get());
.EE
.SH Memory Management
.IP \[bu] 2
If you use \f[CR]new\f[R] you need to use \f[CR]std::destroy\f[R]
somewhere to prevent a leak.
.SS Smart Pointers
\f[CR]std::move\f[R] is usually only used with smart pointers, i.e., to
transfer ownership (which means the \f[CR]std::destroy\f[R] life\-cycle
event will happen for the new class and not the old)
.IP
.EX
std::unique_ptr<int> valuePtr;
valuePtr.reset(\f[B]new\f[R] int(47));
.EE
.SS Dangers
If you have a \f[CR]unique_ptr\f[R] member variable:
.IP
.EX
std::unique_ptr<Foo> foo;
.EE
.PP
You probably never want to assign that via the constructor (e.g.,
don\[cq]t do \f[CR]foo(fooIn)\f[R]) because that will result in a doubly
released pointer as both this member variable, and the original owner,
will calll \f[CR]std::destroy\f[R] on it.
.SH Checks
.IP \[bu] 2
Check whether \f[CR]const\f[R] can be added to every type declaration
(e.g., in arguments, variables [including in loops])
.IP \[bu] 2
If possible, use a reference instead of a pointer
