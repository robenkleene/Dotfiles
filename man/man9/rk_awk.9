.\" Automatically generated by Pandoc 3.5
.\"
.TH "RK_AWK Reference" "" "" ""
.PP
\f[CR]awk\f[R] is for manipulating columns of data.
.IP \[bu] 2
\f[CR]awk \-F, \[aq]{print $5}\[aq]\f[R]: Use \f[CR],\f[R] as a
separator and print the fifth column.
.SH Examples
.SS Learning
.IP \[bu] 2
\f[CR]$0\f[R]: Represents input (i.e., each line)
.PP
\f[CR]awk \[aq]/<regex>/\[aq]\f[R] is short hand for
\f[CR]awk \[aq]$0 \[ti] /<regex>/{print $0}\[aq]\f[R].
.PP
E.g.:
.IP
.EX
$ echo \-n \[dq]foo\[rs]nbar\[dq] | awk \[aq]/foo/\[aq]
foo
.EE
.PP
\f[CR]\[aq]1\[aq]\f[R] (i.e., non\-zero means \[lq]true\[rq]) is the
idiomatic way to print input.
.PP
E.g.:
.IP
.EX
$ printf \[aq]gate\[rs]napple\[rs]nwhat\[rs]nkite\[rs]n\[aq] | awk \[aq]1\[aq]
gate
apple
what
kite
.EE
.SS Capturing Between Delimiters
Capture everything between the first \f[CR]DUMPSTART\f[R] and
\f[CR]DUMPEND\f[R] pair:
.IP
.EX
awk \[aq]/DUMPSTART.*$/,/\[ha].*DUMPEND.*$/{print; if(/DUMPEND.*$/) exit}\[aq]
.EE
.SS Only if key is found
.IP
.EX
#!/usr/bin/awk \-f

/SECTIONSTART/ {
    in_block = 1;
    block = \[dq]\[rs]n\[dq]
}
/SECTIONSTART/,/SECTIONEND/ {
    if (in_block) {
        block = block $0 \[dq]\[rs]n\[dq];
    }
    if (/SECTIONKEY/) {
        found_key = 1;
    }
}
/SECTIONEND/ {
    if (in_block) {
        if (found_key) {
            printf \[dq]%s\[dq], block;
        }
        in_block = 0;
        found_key = 0;
    }
}
.EE
.SS Printing Different Number of Surrounding Lines
.IP
.EX
awk \[aq]/\[dq]title\[dq]:/{print} /\[dq]GlossDef\[dq]/{print; for(i=0;i<4;i++) {getline; print}}\[aq]
.EE
