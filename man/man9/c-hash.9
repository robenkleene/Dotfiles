.\" Automatically generated by Pandoc 3.4
.\"
.TH "C\-HASH" "9" "" "Reference"
.PP
This hash implementation is from chapter 6.6, \[lq]Table Lookup\[rq]
from the \f[I]C Programming Language\f[R].
.SH Hashing Function
.RS
.PP
The hashing function, which is used by both lookup and install, adds
each character value in the string to a scrambled combination of the
previous ones and returns the remainder modulo the array size.
This is not the best possible hash function, but it is short and
effective.
.RE
.IP
.EX
unsigned hash(char *s)
{
    unsigned hashval;
    \f[B]for\f[R] (hashval = 0; *s != \[aq]\[rs]0\[aq]; s++)
      hashval = *s + 31 * hashval;
    \f[B]return\f[R] hashval % HASHSIZE;
}
.EE
.PP
This function takes a \f[CR]char\f[R] pointer, and returns an
\f[CR]unsigned\f[R] to use as an array index.
The basic premise of the function is to take the sum of each letter in
the string multiplied by a prime number.
.IP \[bu] 2
\f[CR]*s + 31 * hashval\f[R]: Multiplying by a prime number to reduce
the chance of a collusion.
Prime numbers are used in hash algorithms because they have the best
chance of being unique when multiplied by another number.
The \f[CR]HASHSIZE\f[R] is set to a prime number
(\f[CR]#define HASHSIZE 101\f[R]) for the same reason.
(It\[cq]s unclear why \f[CR]31\f[R] and not another prime number value
is used.)
.IP \[bu] 2
\f[CR]hashval % HASHSIZE\f[R]: This is just to get the result in the
range \f[CR]0\f[R] to \f[CR]HASHSIZE\f[R].
