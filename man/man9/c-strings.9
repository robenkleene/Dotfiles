.\" Automatically generated by Pandoc 3.4
.\"
.TH "C\-STRINGS" "9" "" "Reference"
.SH String Pointers vs.\ Arrays
C has two ways of storing a string:
.IP \[bu] 2
\f[CR]char*\f[R]: A pointer
.IP \[bu] 2
\f[CR]char[]\f[R]: An array
.PP
These are technically different types, but a \f[CR]char\f[R] array is
coerced into a pointer if it\[cq]s passed as a parameter to a function
that takes a \f[CR]char\f[R] pointer.
.PP
A \f[CR]char\f[R] pointer can be iterated through with \f[CR]s++\f[R],
as in the following examples to print the string:
.IP
.EX
void hash_test(char *s) {
    \f[B]while\f[R] (*s != \[aq]\[rs]0\[aq]) {
        printf(\[dq]%c\[dq], *s);
        s++;
    }
}
.EE
.PP
A \f[CR]char*\f[R] pointer in C points to a single memory address (like
all pointers).
E.g.,:
.IP
.EX
char *p = \[dq]abc\[dq];
.EE
.PP
\f[CR]p\f[R] is the memory address and \f[CR]*p\f[R] is \f[CR]a\f[R]
(e.g., \f[CR]printf(\[dq]%c\[dq], *p);\f[R] prints \f[CR]a\f[R]).
.PP
But in memory, a string literal is actually stored as an array with with
a null character (\f[CR]\[rs]0\f[R]) as the last element:
.IP
.EX
+\-\-\-+      +\-\-\-\-\-+\-\-\-\-\-+\-\-\-\-\-+\-\-\-\-\-\-+
| p | \-\-\-> | \[aq]a\[aq] | \[aq]b\[aq] | \[aq]c\[aq] | \[aq]\[rs]0\[aq] |
+\-\-\-+      +\-\-\-\-\-+\-\-\-\-\-+\-\-\-\-\-+\-\-\-\-\-\-+
.EE
.PP
Some functions in C automatically handle strings, e.g.,
\f[CR]printf(p)\f[R] will print \f[CR]abc\f[R].
\f[CR]printf(\[dq]%s\[dq], p);\f[R] can also be used to print the entire
string.
.SH Converting \f[CR]char\f[R] to \f[CR]int\f[R]
Characters are \f[CR]int\f[R] which has a couple of implications.
.PP
If \f[CR]c\f[R] is a single\-character digit, then the expression
\f[CR]c \- \[aq]0\[aq]\f[R] will convert that digit to an
\f[CR]int\f[R].
.IP
.EX
c\ \-\ \[aq]0\[aq]
.EE
.PP
The ASCII value of a digit can be printed by using the \f[CR]int\f[R]
(\f[CR]%i\f[R]) format specifier.
.IP
.EX
printf(\[dq]%c = %i\[rs]n\[dq], *s, *s);
.EE
