.\" Automatically generated by Pandoc 3.6.3
.\"
.TH "RK_LANG_BASH_SNIP Reference" "" "" ""
.SH Print variable
.IP
.EX
echo \[dq]$1 = \[rs]$${1}\[dq]
.EE
.SH Print
.IP
.EX
echo \[dq]${1:Message}\[dq]
.EE
.SH Print error
.IP
.EX
echo \[dq]${1:Error}\[dq] >&2
.EE
.SH Bash template
.IP
.EX
#!/usr/bin/env bash

set \-euo pipefail

.EE
.SH Echo array variable
.IP
.EX
echo \[dq]$1 = \[rs]${${1}[\[at]]}\[dq]
.EE
.SH Remove variable trailing slash
.IP
.EX
\[rs]${${0:1}%/}
.EE
.SH Remove path extension
.IP
.EX
\[rs]${${0:1}%.*}
.EE
.SH Get array element
.IP
.EX
\[rs]${${0:args}[\[at]]}
.EE
.SH Function
.IP
.EX
${1:my_function}() {
  ${0:echo \[rs]$1}
}
.EE
.SH Test expression
.IP
.EX
[[ ${0:true} ]]
.EE
.SH If statement
.IP
.EX
if ${1:true}; then
  ${0:echo \[dq]true\[dq]}
fi
.EE
.SH If \f[CR]uname\f[R]
.IP
.EX
if [[ \[dq]\[rs]$(uname)\[dq] = \[dq]Darwin\[dq] ]]; then
  echo \[dq]Darwin\[dq]
elif [[ \[dq]\[rs]$(uname)\[dq] = \[dq]Linux\[dq] ]]; then
  echo \[dq]Linux\[dq]
fi
.EE
.SH If args
.IP
.EX
if [[ $# ${1:\-ne} ${2:0} ]]; then
  ${0:echo \[dq]\[rs]$1\[dq]}
fi
.EE
.SH True if directory
.IP
.EX
\-d \[dq]${0:\[rs]$1}\[dq]
.EE
.SH Test boolean
.IP
.EX
\[dq]$${1:value}\[dq] == \[dq]${0:true}\[dq]
.EE
.SH True if regular file
.IP
.EX
\-f \[dq]${0:\[rs]$1}\[dq]
.EE
.SH True if file exists
.IP
.EX
\-e \[dq]${0:\[rs]$1}\[dq]
.EE
.SH True if symbolic link
.IP
.EX
\-L \[dq]${0:\[rs]$1}\[dq]
.EE
.SH True if equal
.IP
.EX
${1:\[rs]$?} \-eq ${0:0}
.EE
.SH True if greater than
.IP
.EX
${1:\[rs]$?} \-gt ${0:0}
.EE
.SH True if less than
.IP
.EX
${1:\[rs]$?} \-lt ${0:0}
.EE
.SH True if empty variable
.IP
.EX
\-z \[dq]${${0:1}:\-}\[dq]
.EE
.SH True if not empty variable
.IP
.EX
\-n \[dq]${${0:1}:\-}\[dq]
.EE
.SH True if no args
.IP
.EX
$# \-eq ${0:0}
.EE
.SH True if variable matches string
.IP
.EX
\[dq]$${1:1}\[dq] = \[dq]${0:string}\[dq]
.EE
.SH True if command is executable
.IP
.EX
\-x \[dq]$(command \-v ${0:ls})\[dq]
.EE
.SH True if \f[CR]uname\f[R] matches
.IP
.EX
\[dq]$(uname)\[dq] = \[dq]Linux\[dq]
.EE
.SH While loop one\-liner
.IP
.EX
while read i; do { ${0:echo $i} } done
.EE
.SH While loop
.IP
.EX
while read i; do
  ${0:echo $i}
done
.EE
.SH For loop
.IP
.EX
for ${1:name} in ${2:\[dq]\[rs]$\[at]\[dq]}; do
  echo \[dq]\[rs]$$name\[dq]
done
.EE
.SH For loop directories
.IP
.EX
for dir in */; do
  echo $dir;
done
.EE
.SH For loop one\-liner
.IP
.EX
for i in ${1:*}; do { ${0:echo $i} } done
.EE
.SH Rename files in current directory
.IP
.EX
for i in *; do { mv $i \[rs]\[ga]echo $i | tr \[aq][A\-Z]\[aq] \[aq][a\-z]\[aq] | tr \[aq] \[aq] \[aq]\-\[aq]\[rs]\[ga] } done
.EE
.SH Exit status
.IP
.EX
\[rs]$?
.EE
.SH Set IFS
.IP
.EX
old_IFS=$IFS
IFS=\[dq]${1: }\[dq]
IFS=${old_IFS}
.EE
.SH Script directory
.IP
.EX
cd \[rs]$(dirname \[dq]\[rs]$0\[dq] || exit 1)
.EE
.SH \f[CR]getopts\f[R]
.IP
.EX
force=\[dq]false\[dq]
while getopts \[dq]:p:fh\[dq] option; do
  case \[dq]\[rs]$option\[dq] in
    p)
      file_path=\[dq]\[rs]$OPTARG\[dq]
      ;;
    f)
      force=\[dq]true\[dq]
      ;;
    h)
      echo \[dq]Usage: command [\-hf] [\-p <file_path>]\[dq]
      exit 0
      ;;
    :)
      echo \[dq]Option \-\[rs]$OPTARG requires an argument\[dq] >&2
      exit 1
      ;;
    \[rs]?)
      echo \[dq]Invalid option: \-\[rs]$OPTARG\[dq] >&2
      exit 1
      ;;
  esac
done
.EE
