.\" Automatically generated by Pandoc 3.6
.\"
.TH "RK_C_STRUCT Reference" "" "" ""
.PP
Declare a \f[CR]struct\f[R]:
.IP
.EX
\f[B]struct\f[R] point {
    int x;
    int y;
};
.EE
.PP
Declare a \f[CR]struct\f[R] variable:
.IP
.EX
\f[B]struct\f[R] point pt;
.EE
.PP
A \f[CR]struct\f[R] variable can be declared and initialized at once by
providing member values:
.IP
.EX
\f[B]struct\f[R] point maxpt = { 320, 200 };
.EE
.PP
Member values can be accessed with dot notation:
.IP
.EX
printf(\[dq]%d, %d\[rs]n\[dq], pt.x, pt.y);
.EE
.PP
Declaring a \f[CR]struct1\f[R] and a variable at the same time;
.IP
.EX
\f[B]struct\f[R] point {
    int x;
    int y;
} myPoint;

int main() {
    myPoint.x = 5;
    myPoint.y = 10;
}
.EE
.PP
Declaring a \f[CR]struct\f[R] with a \f[CR]typedef\f[R]:
.IP
.EX
\f[B]typedef\f[R] \f[B]struct\f[R] {
    int x;
    int y;
} point_t;

int main() {
    point_t maxpt = { 320, 200 };
}
.EE
.PP
You can\[cq]t use a \f[CR]typedef\f[R] being defined within a
\f[CR]struct\f[R] itself, but you can\[cq]t use a type name, resulting
in the following:
.IP
.EX
\f[B]typedef\f[R] \f[B]struct\f[R] node {
    int val;
    \f[B]struct\f[R] node *next;
} node_t;
.EE
