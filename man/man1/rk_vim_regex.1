.\" Automatically generated by Pandoc 3.6.3
.\"
.TH "RK_VIM_REGEX Reference" "" "" ""
.SH Magic
.IP \[bu] 2
\f[CR]magic\f[R] is the default setting, this means non\-greedy is
\f[CR]\[rs]{\-}\f[R] and capture groups is \f[CR]\[rs](\[rs])\f[R].
.IP \[bu] 2
\f[CR]\[rs]|\f[R] is Vim\[cq]s version of \[lq]or\[rq]
.RS 2
.PP
matches none `magic' `nomagic' none $ $ $ $ matches_end\-of\-line .
\&.
\&.
\&.
matches_any_character
\[bu] .RS 2
.IP
.EX
*        \[rs]*         \[rs]*    any_number_of_the_previous_atom
.EE
\[ti] \[ti] \[ti] \[ti] latest_substitute_string () () () ()
grouping_into_an_atom | | | | separating_alternatives
alphabetic_character \[rs] \[rs] \[rs] \[rs] literal_backslash .
\&.
\&.
\&.
literal_dot { { { { literal_`{' a a a a literal_`a'
.RE
.RE
.SH Pattern Modifiers
.IP \[bu] 2
\f[CR]/\[rs]v\f[R]: Very magic search makes most special characters take
on their meaning.
.IP \[bu] 2
\f[CR]/\[rs]V\f[R]: \f[CR]verynomagic\f[R] search, no special
characters, everything is interpreted literally.
.IP \[bu] 2
\f[CR]/\[rs]c\f[R]: Ignore case
.IP \[bu] 2
\f[CR]/\[rs]C\f[R]: Case sensitive
.PP
By default Vim searches for the literal characters for most punctuation
(excluding \f[CR][]\f[R], \f[CR].\f[R], \f[CR]*\f[R], others?
These need to be normally need to be escaped).
.SH Special Characters
.IP \[bu] 2
Use \f[CR]\[rs]{\-}\f[R] instead of \f[CR]*\f[R] for non\-greedy (or
\f[CR]{\-}\f[R] with \f[CR]\[rs]v\f[R])
.IP \[bu] 2
\f[CR].\f[R]: Any character except new line
.SS More
.IP \[bu] 2
\f[CR]\[rs]<\f[R] / \f[CR]\[rs]>\f[R]: Word start / end (matches a
\f[I]position\f[R], not a character, e.g., can match EOL)
.IP \[bu] 2
\f[CR]\[rs]a\f[R] / \f[CR]\[rs]A\f[R]: Alphabetic / non\-alphabetic
character
.IP \[bu] 2
\f[CR]\[rs]d\f[R] / \f[CR]\[rs]D\f[R]: Digit / non\-digit
.IP \[bu] 2
\f[CR]\[rs]h\f[R] / \f[CR]\[rs]H\f[R]: Head of word character
(\f[CR]a\f[R], \f[CR]b\f[R], \f[CR]c...z\f[R],\f[CR]A\f[R],
\f[CR]B\f[R], \f[CR]C...Z\f[R] and \f[CR]_\f[R]) / non\-head of word
character
.IP \[bu] 2
\f[CR]\[rs]l\f[R] / \f[CR]\[rs]L\f[R]: Lowercase / non\-lowercase
character character
.IP \[bu] 2
\f[CR]\[rs]o\f[R] / \f[CR]\[rs]O\f[R]: Octal digit / non\-octal digit
.IP \[bu] 2
\f[CR]\[rs]p\f[R]/ \f[CR]\[rs]P\f[R]: Printable character / Like
\f[CR]\[rs]p\f[R], but excluding digits
.IP \[bu] 2
\f[CR]\[rs]s\f[R] / \f[CR]\[rs]S\f[R]: Whitespace character /
non\-whitespace character
.IP \[bu] 2
\f[CR]\[rs]u\f[R] / \f[CR]\[rs]U\f[R]: Uppercase non\-uppercase
character
.IP \[bu] 2
\f[CR]\[rs]w\f[R] / \f[CR]\[rs]W\f[R]: Word character / non\-word
character
.IP \[bu] 2
\f[CR]\[rs]x\f[R] / \f[CR]\[rs]X\f[R]: Hex digit / non\-hex digit
.SH Notes
.IP \[bu] 2
To find and replace whole words only, use
\f[CR]s/\[rs]<word\[rs]>/newword/g\f[R].
(Note that the \f[CR]*\f[R] and \f[CR]#\f[R] commands populate the
current word with this, so you can get use those commands to populate
the \f[CR]/\f[R] register with the search term.)
