.\" Automatically generated by Pandoc 3.9
.\"
.TH "RK_SH_SNIP Reference" "" "" ""
.SH Print variable
.IP
.EX
echo \(dq$1 = \(rs$${1}\(dq
.EE
.SH Print
.IP
.EX
echo \(dq${1:Message}\(dq
.EE
.SH Print error
.IP
.EX
echo \(dq${1:Error}\(dq >&2
.EE
.SH Bash template
.IP
.EX
#!/usr/bin/env bash

set \-euo pipefail

.EE
.SH Echo array variable
.IP
.EX
echo \(dq$1 = \(rs${${1}[\(at]}\(dq
.EE
.SH Remove variable trailing slash
.IP
.EX
\(rs${${0:1}%/}
.EE
.SH Remove path extension
.IP
.EX
\(rs${${0:1}%.*}
.EE
.SH Get array element
.IP
.EX
\(rs${${0:args}[\(at]}
.EE
.SH Function
.IP
.EX
${1:my_function}() {
  ${0:echo \(rs$1}
}
.EE
.SH Test expression
.IP
.EX
[[ ${0:true} ]]
.EE
.SH If statement
.IP
.EX
if ${1:true}; then
  ${0:echo \(dqtrue\(dq}
fi
.EE
.SH If \f[CR]uname\f[R]
.IP
.EX
if [[ \(dq\(rs$(uname)\(dq = \(dqDarwin\(dq ]]; then
  echo \(dqDarwin\(dq
elif [[ \(dq\(rs$(uname)\(dq = \(dqLinux\(dq ]]; then
  echo \(dqLinux\(dq
fi
.EE
.SH If args
.IP
.EX
if [[ $# ${1:\-ne} ${2:0} ]]; then
  ${0:echo \(dq\(rs$1\(dq}
fi
.EE
.SH True if directory
.IP
.EX
\-d \(dq${0:\(rs$1}\(dq
.EE
.SH Test boolean
.IP
.EX
\(dq$${1:value}\(dq == \(dq${0:true}\(dq
.EE
.SH True if regular file
.IP
.EX
\-f \(dq${0:\(rs$1}\(dq
.EE
.SH True if file exists
.IP
.EX
\-e \(dq${0:\(rs$1}\(dq
.EE
.SH True if symbolic link
.IP
.EX
\-L \(dq${0:\(rs$1}\(dq
.EE
.SH True if equal
.IP
.EX
${1:\(rs$?} \-eq ${0:0}
.EE
.SH True if greater than
.IP
.EX
${1:\(rs$?} \-gt ${0:0}
.EE
.SH True if less than
.IP
.EX
${1:\(rs$?} \-lt ${0:0}
.EE
.SH True if empty variable
.IP
.EX
\-z \(dq${${0:1}:\-}\(dq
.EE
.SH True if not empty variable
.IP
.EX
\-n \(dq${${0:1}:\-}\(dq
.EE
.SH True if no args
.IP
.EX
$# \-eq ${0:0}
.EE
.SH True if variable matches string
.IP
.EX
\(dq$${1:1}\(dq = \(dq${0:string}\(dq
.EE
.SH True if command is executable
.IP
.EX
\-x \(dq$(command \-v ${0:ls})\(dq
.EE
.SH True if \f[CR]uname\f[R] matches
.IP
.EX
\(dq$(uname)\(dq = \(dqLinux\(dq
.EE
.SH While loop one\-liner
.IP
.EX
while read i; do { ${0:echo $i} } done
.EE
.SH While loop
.IP
.EX
while read i; do
  ${0:echo $i}
done
.EE
.SH For loop
.IP
.EX
for ${1:name} in ${2:\(dq\(rs$\(at\(dq}; do
  echo \(dq\(rs$$name\(dq
done
.EE
.SH For loop directories
.IP
.EX
for dir in */; do
  echo $dir;
done
.EE
.SH For loop one\-liner
.IP
.EX
for i in ${1:*}; do { ${0:echo $i} } done
.EE
.SH Rename files in current directory
.IP
.EX
for i in *; do { mv $i \(rs\(gaecho $i | tr \(aq[A\-Z]\(aq \(aq[a\-z]\(aq | tr \(aq \(aq \(aq\-\(aq\(rs\(ga } done
.EE
.SH Exit status
.IP
.EX
\(rs$?
.EE
.SH Set IFS
.IP
.EX
old_IFS=$IFS
IFS=\(dq${1: }\(dq
IFS=${old_IFS}
.EE
.SH Script directory
.IP
.EX
cd \(rs$(dirname \(dq\(rs$0\(dq || exit 1)
.EE
.SH \f[CR]getopts\f[R]
.IP
.EX
force=\(dqfalse\(dq
while getopts \(dq:p:fh\(dq option; do
  case \(dq\(rs$option\(dq in
    p)
      file_path=\(dq\(rs$OPTARG\(dq
      ;;
    f)
      force=\(dqtrue\(dq
      ;;
    h)
      echo \(dqUsage: command [\-hf] [\-p <file_path>]\(dq
      exit 0
      ;;
    :)
      echo \(dqOption \-\(rs$OPTARG requires an argument\(dq >&2
      exit 1
      ;;
    \(rs?)
      echo \(dqInvalid option: \-\(rs$OPTARG\(dq >&2
      exit 1
      ;;
  esac
done
.EE
